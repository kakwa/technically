{{ $url := .Get "url" }}
{{ $height := .Get "height" | default "600px" }}
{{ $width := .Get "width" | default $height }}
{{ $caption := .Get "caption" }}

<figure>
    <div style="width: {{ $width }}; height: {{ $height }}; position: relative; margin: 0;">
        <div id="stl-container-{{ .Ordinal }}" style="width: 100%; height: 100%; border-radius: 8px; overflow: hidden;"></div>
        <div id="stl-loading-{{ .Ordinal }}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff;">
            <div style="border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid #00d4ff; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto;"></div>
            <p style="margin-top: 1rem;">Loading 3D model...</p>
        </div>
        <div style="position: absolute; bottom: 10px; right: 10px; display: flex; gap: 5px; z-index: 10;">
            <button id="zoom-in-{{ .Ordinal }}" style="width: 40px; height: 40px; border: none; border-radius: 5px; background: rgba(0, 0, 0, 0.6); color: white; font-size: 20px; cursor: pointer; backdrop-filter: blur(5px);">+</button>
            <button id="zoom-out-{{ .Ordinal }}" style="width: 40px; height: 40px; border: none; border-radius: 5px; background: rgba(0, 0, 0, 0.6); color: white; font-size: 20px; cursor: pointer; backdrop-filter: blur(5px);">âˆ’</button>
        </div>
    </div>
    {{ if $caption }}
    <figcaption>
        <p>{{ $caption }}</p>
    </figcaption>
    {{ end }}
</figure>

<script src="/js/three.min.js"></script>
<script>
(function() {
    const containerId = 'stl-container-{{ .Ordinal }}';
    const loadingId = 'stl-loading-{{ .Ordinal }}';
    const zoomInId = 'zoom-in-{{ .Ordinal }}';
    const zoomOutId = 'zoom-out-{{ .Ordinal }}';
    
    const container = document.getElementById(containerId);
    const loading = document.getElementById(loadingId);
    const zoomInBtn = document.getElementById(zoomInId);
    const zoomOutBtn = document.getElementById(zoomOutId);
    
    let scene, camera, renderer, mesh, controls;

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a1628); // Darker blue

        const width = container.clientWidth;
        const height = container.clientHeight;

        camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.set(0, 0, 50);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(1, 1, 1);
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-1, -1, -1);
        scene.add(directionalLight2);

        setupControls();
        loadSTL('{{ $url }}');

        window.addEventListener('resize', onWindowResize);
        
        // Zoom buttons
        zoomInBtn.addEventListener('click', () => {
            controls.zoom = Math.max(10, controls.zoom - 5);
        });
        
        zoomOutBtn.addEventListener('click', () => {
            controls.zoom = Math.min(200, controls.zoom + 5);
        });
    }

    function setupControls() {
        controls = {
            isDragging: false,
            isPanning: false,
            previousMousePosition: { x: 0, y: 0 },
            rotation: { x: Math.PI / 4, y: Math.PI / 4 }, // 45 degrees on X and Y
            pan: { x: 0, y: 0 },
            zoom: 50
        };

        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    function onMouseDown(e) {
        if (e.button === 0) controls.isDragging = true;
        else if (e.button === 2) controls.isPanning = true;
        controls.previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseMove(e) {
        if (controls.isDragging) {
            const deltaX = e.clientX - controls.previousMousePosition.x;
            const deltaY = e.clientY - controls.previousMousePosition.y;
            controls.rotation.y += deltaX * 0.01;
            controls.rotation.x += deltaY * 0.01;
        } else if (controls.isPanning) {
            const deltaX = e.clientX - controls.previousMousePosition.x;
            const deltaY = e.clientY - controls.previousMousePosition.y;
            controls.pan.x += deltaX * 0.05;
            controls.pan.y -= deltaY * 0.05;
        }
        controls.previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseUp() {
        controls.isDragging = false;
        controls.isPanning = false;
    }

    function loadSTL(url) {
        fetch(url)
            .then(response => response.arrayBuffer())
            .then(data => {
                const geometry = parseSTL(data);
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshPhongMaterial({
                    color: 0x00d4ff,
                    specular: 0x111111,
                    shininess: 200,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                
                mesh = new THREE.Mesh(geometry, material);
                
                geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                geometry.boundingBox.getCenter(center);
                geometry.translate(-center.x, -center.y, -center.z);
                
                // Apply initial 45-degree rotation on Z axis as well
                mesh.rotation.z = Math.PI / 4;
                
                scene.add(mesh);
                loading.style.display = 'none';
                animate();
            })
            .catch(error => {
                loading.innerHTML = 'Error loading STL: ' + error.message;
            });
    }

    function parseSTL(data) {
        const view = new DataView(data);
        const isASCII = isASCIISTL(data);
        return isASCII ? parseASCIISTL(data) : parseBinarySTL(view);
    }

    function isASCIISTL(data) {
        const text = new TextDecoder().decode(new Uint8Array(data, 0, Math.min(1000, data.byteLength)));
        return text.indexOf('solid') === 0;
    }

    function parseBinarySTL(view) {
        const faces = view.getUint32(80, true);
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        
        for (let i = 0; i < faces; i++) {
            const offset = 84 + i * 50;
            for (let j = 0; j < 3; j++) {
                const vertexOffset = offset + 12 + j * 12;
                vertices.push(
                    view.getFloat32(vertexOffset, true),
                    view.getFloat32(vertexOffset + 4, true),
                    view.getFloat32(vertexOffset + 8, true)
                );
            }
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        return geometry;
    }

    function parseASCIISTL(data) {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const text = new TextDecoder().decode(data);
        const lines = text.split('\n');
        
        for (let line of lines) {
            line = line.trim();
            if (line.startsWith('vertex')) {
                const parts = line.split(/\s+/);
                vertices.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
            }
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        return geometry;
    }

    function onWindowResize() {
        const width = container.clientWidth;
        const height = container.clientHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        if (mesh) {
            mesh.rotation.x = controls.rotation.x;
            mesh.rotation.y = controls.rotation.y;
        }
        
        if (mesh) {
            mesh.position.x = controls.pan.x;
            mesh.position.y = controls.pan.y;
        }
        
        camera.position.z = controls.zoom;
        renderer.render(scene, camera);
    }

    init();
})();
</script>

<style>
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
</style>
